package xyz.tomd.cameldemos.springboot.artemis;

import org.apache.camel.CamelContext;
import org.apache.camel.EndpointInject;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.AdviceWithRouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.spring.CamelSpringBootRunner;
import org.apache.camel.test.spring.MockEndpointsAndSkip;
import org.apache.camel.test.spring.UseAdviceWith;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.DirtiesContext;

@RunWith(CamelSpringBootRunner.class)
@MockEndpointsAndSkip("jms:*")
@SpringBootTest
@DirtiesContext
@UseAdviceWith
public class CamelArtemisApplicationTest {

    @Autowired
    ProducerTemplate template;

    @Autowired
    CamelContext camelContext;

    @EndpointInject("mock:jms:queue:INCOMING")
    MockEndpoint mockIncomingEndpoint;

    @EndpointInject("mock:jms:queue:PROCESSED")
    MockEndpoint mockProcessedEndpoint;

    @Before
    public void setUp() throws Exception {
        // As we've used UseAdviceWith, we can do any route modifications
        // we want, but then we must start the CamelContext manually

        // Replace the first step in the 'receive-route' with "direct:receive"
        AdviceWithRouteBuilder.adviceWith(camelContext, "receive-route",
                a -> a.replaceFromWith("direct:receive")
        );
        camelContext.start();
    }

    /**
     * Test that our mock endpoint receives a message generated by the timer
     * @throws InterruptedException
     */
    @Test
    public void testMockReceivesTimerMessage() throws InterruptedException {
        mockIncomingEndpoint.expectedMessageCount(1);
        mockIncomingEndpoint.expectedBodiesReceived("HELLO from Camel!");
        mockIncomingEndpoint.assertIsSatisfied(1500L);
    }


    /**
     * Test that we can send a message to our second route, and it arrives
     * at the mock endpoint unchanged
     * @throws InterruptedException
     */
    @Test
    public void testReceiveRouteReceivesOK() throws InterruptedException {
        // These MUST appear first! Otherwise the assertions are set up after the message has been sent.
        mockProcessedEndpoint.expectedMessageCount(1);
        mockProcessedEndpoint.expectedBodiesReceived("Just a test message");

        // Send a message to the new replacement "direct:receive" endpoint
        template.sendBody("direct:receive", "Just a test message");

        // This passes because there is no mock
        mockProcessedEndpoint.assertIsSatisfied();
    }
}
